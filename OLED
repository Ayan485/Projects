// #include <Arduino.h>
// #include <Wire.h>
// #include <Adafruit_GFX.h>
// #include <Adafruit_SSD1306.h>
// #include <Adafruit_MPU6050.h>
// #include <Adafruit_Sensor.h>

// // --------- FIXED I2C PINS ----------
// #define SDA_PIN 4
// #define SCL_PIN 9

// // --------- OLED ----------
// #define SCREEN_WIDTH 128
// #define SCREEN_HEIGHT 64
// Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

// // --------- MPU6050 ----------
// Adafruit_MPU6050 mpu;

// // --------- GLOBAL FOUND ADDRESS ----------
// byte oledAddress = 0;


// // --------- SIMPLE I2C SCANNER ----------
// byte scanI2C() {
//   Serial.println("Scanning I2C bus...");
  
//   for (byte addr = 1; addr < 127; addr++) {
//     Wire.beginTransmission(addr);
//     if (Wire.endTransmission() == 0) {
//       Serial.print("FOUND DEVICE @ 0x");
//       Serial.println(addr, HEX);
//       return addr; // return first device found
//     }
//   }
//   Serial.println("No I2C device found!");
//   return 0;
// }


// // ---- Helper: show splash text for 1 second ----
// void showSplash(const char* text) {
//   display.clearDisplay();
//   display.setTextSize(2);
//   display.setTextColor(SSD1306_WHITE);

//   int16_t x1, y1;
//   uint16_t w, h;
//   display.getTextBounds(text, 0, 0, &x1, &y1, &w, &h);
//   display.setCursor((SCREEN_WIDTH - w) / 2, (SCREEN_HEIGHT - h) / 2);
//   display.print(text);
//   display.display();
//   delay(1000);
// }


// // ---- Draw Z rotation indicator ----
// void drawZRotation(float zDeg) {
//   // Circle
//   display.drawCircle(64, 32, 25, SSD1306_WHITE);

//   // Convert degrees to radians
//   float rad = zDeg * 0.0174533;

//   // End of rotating line
//   int x = 64 + cos(rad) * 20;
//   int y = 32 + sin(rad) * 20;

//   display.drawLine(64, 32, x, y, SSD1306_WHITE);
// }


// // ---- Movement Display ----
// void showMove(const char* text) {
//   display.clearDisplay();
//   display.setTextSize(2);
//   display.setTextColor(SSD1306_WHITE);
//   display.setCursor(20, 20);
//   display.print(text);
//   display.display();
// }


// // -------------------- SETUP --------------------
// void setup() {
//   Serial.begin(115200);
//   delay(200);

//   // EXACT WORKING INITIALIZATION (do NOT change)
//   Wire.begin(SDA_PIN, SCL_PIN);
//   delay(200);

//   oledAddress = scanI2C();
//   if (oledAddress == 0) {
//     Serial.println("ERROR: No OLED found!");
//     while (1);
//   }

//   Serial.print("Using OLED address: 0x");
//   Serial.println(oledAddress, HEX);

//   if (!display.begin(SSD1306_SWITCHCAPVCC, oledAddress)) {
//     Serial.println("OLED INIT FAILED!");
//     while (1);
//   }

//   // ----- BOOT UP SEQUENCE -----
//   showSplash("Welcome");
//   showSplash("Vacuum");
//   showSplash("Robot");
//   showSplash("Starting");
//   showSplash("Ready!");

//   // ----- INITIALIZE MPU6050 -----
//   if (!mpu.begin()) {
//     Serial.println("MPU NOT FOUND!");
//     while (1);
//   }

//   mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
//   mpu.setGyroRange(MPU6050_RANGE_500_DEG);
//   Serial.println("MPU6050 Ready");
// }


// // -------------------- LOOP --------------------
// void loop() {

//   // -------- Read IMU --------
//   sensors_event_t accel, gyro, temp;
//   mpu.getEvent(&accel, &gyro, &temp);

//   float zRotDeg = gyro.gyro.z * 57.2958;  // Convert rad/s to deg/s

//   // -------- Display IMU --------
//   display.clearDisplay();
//   display.setTextSize(1);
//   display.setCursor(0, 0);
//   display.println("IMU:");
//   display.print("Z rot: ");
//   display.print(zRotDeg);
//   display.println(" deg/s");

//   // Draw rotation axis
//   drawZRotation(zRotDeg);

//   display.display();
//   delay(50);


//   // -------- Movement Test (examples) --------
//   // Uncomment these when you connect your motors:
//   //
//   // showMove("Forward");
//   // delay(500);
//   // showMove("Backward");
//   // delay(500);
//   // showMove("Left");
//   // delay(500);
//   // showMove("Right");
//   // delay(500);

// }
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "driver/i2c.h"
#include "esp_log.h"

// ---------------- I2C Pins -------------------
#define SDA_PIN 4
#define SCL_PIN 9
#define I2C_PORT I2C_NUM_0

// ---------------- SSD1306 --------------------
#define SSD1306_WIDTH 128
#define SSD1306_HEIGHT 64
#define SSD1306_ADDR 0x3C

uint8_t oled_buffer[SSD1306_WIDTH * SSD1306_HEIGHT / 8];

// ---------------- MPU6050 --------------------
#define MPU6050_ADDR 0x68
#define REG_PWR_MGMT_1 0x6B
#define REG_GYRO_ZOUT_H 0x47

// -------------------------------------------------------
// INLINED 5×7 FONT (ASCII 32–127)
// -------------------------------------------------------
static const uint8_t font5x7[][5] = {
    {0,0,0,0,0}, {0,0,0x5F,0,0}, {0,7,0,7,0}, {0x14,0x7F,0x14,0x7F,0x14},
    {0x24,0x2A,0x7F,0x2A,0x12}, {0x23,0x13,8,0x64,0x62}, {0x36,0x49,0x55,0x22,0x50},
    {0,5,3,0,0}, {0,0x1C,0x22,0x41,0}, {0,0x41,0x22,0x1C,0},
    {0x14,8,0x3E,8,0x14}, {8,8,0x3E,8,8}, {0,0x50,0x30,0,0},
    {8,8,8,8,8}, {0,0x60,0x60,0,0}, {0x20,0x10,8,4,2},
    {0x3E,0x51,0x49,0x45,0x3E}, {0,0x42,0x7F,0x40,0}, {0x42,0x61,0x51,0x49,0x46},
    {0x21,0x41,0x45,0x4B,0x31}, {0x18,0x14,0x12,0x7F,0x10},
    {0x27,0x45,0x45,0x45,0x39}, {0x3C,0x4A,0x49,0x49,0x30},
    {1,0x71,9,5,3}, {0x36,0x49,0x49,0x49,0x36},
    {6,0x49,0x49,0x29,0x1E}, {0,0x36,0x36,0,0},
    {0,0x56,0x36,0,0}, {8,0x14,0x22,0x41,0},
    {0x14,0x14,0x14,0x14,0x14}, {0,0x41,0x22,0x14,8},
    {2,1,0x51,9,6}, {0x32,0x49,0x79,0x41,0x3E},
    {0x7E,0x11,0x11,0x11,0x7E}, {0x7F,0x49,0x49,0x49,0x36},
    {0x3E,0x41,0x41,0x41,0x22}, {0x7F,0x41,0x41,0x22,0x1C},
    {0x7F,0x49,0x49,0x49,0x41}, {0x7F,9,9,9,1},
    {0x3E,0x41,0x49,0x49,0x7A}, {0x7F,8,8,8,0x7F},
    {0,0x41,0x7F,0x41,0}, {0x20,0x40,0x41,0x3F,1},
    {0x7F,8,0x14,0x22,0x41}, {0x7F,0x40,0x40,0x40,0x40},
    {0x7F,2,0x0C,2,0x7F}, {0x7F,4,8,0x10,0x7F},
    {0x3E,0x41,0x41,0x41,0x3E}, {0x7F,9,9,9,6},
    {0x3E,0x41,0x51,0x21,0x5E}, {0x7F,9,0x19,0x29,0x46},
    {0x46,0x49,0x49,0x49,0x31}, {1,1,0x7F,1,1},
    {0x3F,0x40,0x40,0x40,0x3F}, {0x1F,0x20,0x40,0x20,0x1F},
    {0x3F,0x40,0x38,0x40,0x3F}, {0x63,0x14,8,0x14,0x63},
    {7,8,0x70,8,7}, {0x61,0x51,0x49,0x45,0x43},
    {0,0x7F,0x41,0x41,0}, {2,4,8,0x10,0x20},
    {0,0x41,0x41,0x7F,0}, {4,2,1,2,4},
    {0x40,0x40,0x40,0x40,0x40}, {0,1,2,4,0},
    {0x20,0x54,0x54,0x54,0x78}, {0x7F,0x48,0x44,0x44,0x38},
    {0x38,0x44,0x44,0x44,0x20}, {0x38,0x44,0x44,0x48,0x7F},
    {0x38,0x54,0x54,0x54,0x18}, {8,0x7E,9,1,2},
    {0x0C,0x52,0x52,0x52,0x3E}, {0x7F,8,4,4,0x78},
    {0,0x44,0x7D,0x40,0}, {0x20,0x40,0x44,0x3D,0},
    {0x7F,0x10,0x28,0x44,0}, {0,0x41,0x7F,0x40,0},
    {0x7C,4,0x18,4,0x7C}, {0x7C,8,4,4,0x78},
    {0x38,0x44,0x44,0x44,0x38}, {0x7C,0x14,0x14,0x14,8},
    {8,0x14,0x14,0x14,0x7C}, {0x7C,8,4,4,8},
    {0x48,0x54,0x54,0x54,0x20}, {4,0x3F,0x44,0x40,0x20},
    {0x3C,0x40,0x40,0x20,0x7C}, {0x1C,0x20,0x40,0x20,0x1C},
    {0x3C,0x40,0x30,0x40,0x3C}, {0x44,0x28,0x10,0x28,0x44},
    {0x0C,0x50,0x50,0x50,0x3C}, {0x44,0x64,0x54,0x4C,0x44}
};

// -------------------------------------------------------
// BASIC I2C FUNCTIONS
// -------------------------------------------------------
esp_err_t i2c_write_reg(uint8_t addr, uint8_t reg, uint8_t data) {
    uint8_t buf[2] = {reg, data};
    return i2c_master_write_to_device(I2C_PORT, addr, buf, 2, 1000 / portTICK_PERIOD_MS);
}

esp_err_t i2c_read_reg(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) {
    return i2c_master_write_read_device(I2C_PORT, addr, &reg, 1, data, len, 1000 / portTICK_PERIOD_MS);
}

// -------------------------------------------------------
// OLED LOW-LEVEL
// -------------------------------------------------------
void oled_cmd(uint8_t c) {
    uint8_t buf[2] = {0x00, c};
    i2c_master_write_to_device(I2C_PORT, SSD1306_ADDR, buf, 2, 10);
}

void oled_data(uint8_t *data, size_t len) {
    uint8_t prefix = 0x40;
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, SSD1306_ADDR << 1, true);
    i2c_master_write_byte(cmd, prefix, true);
    i2c_master_write(cmd, data, len, true);
    i2c_master_stop(cmd);
    i2c_master_cmd_begin(I2C_PORT, cmd, 50 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);
}

void oled_update() {
    oled_cmd(0x21); oled_cmd(0); oled_cmd(127);
    oled_cmd(0x22); oled_cmd(0); oled_cmd(7);
    oled_data(oled_buffer, sizeof(oled_buffer));
}

void oled_clear() {
    memset(oled_buffer, 0, sizeof(oled_buffer));
    oled_update();
}

void oled_pixel(int x, int y) {
    if (x<0 || x>=128 || y<0 || y>=64) return;
    oled_buffer[x + (y>>3)*128] |= 1 << (y&7);
}

// -------------------------------------------------------
// TEXT
// -------------------------------------------------------
void oled_char(int x, int y, char c) {
    if (c < 32 || c > 126) return;
    for (int i=0;i<5;i++) {
        uint8_t col = font5x7[c-32][i];
        for (int j=0;j<7;j++) {
            if (col & (1<<j)) oled_pixel(x+i, y+j);
        }
    }
}

void oled_text(int x,int y,const char *s) {
    while (*s) {
        oled_char(x,y,*s++);
        x+=6;
    }
}

// -------------------------------------------------------
// DRAW SHAPES
// -------------------------------------------------------
void oled_line(int x0,int y0,int x1,int y1){
    int dx=abs(x1-x0),sx=x0<x1?1:-1;
    int dy=-abs(y1-y0),sy=y0<y1?1:-1;
    int err=dx+dy,e2;
    while (1){
        oled_pixel(x0,y0);
        if (x0==x1 && y0==y1) break;
        e2=2*err;
        if (e2>=dy){ err+=dy; x0+=sx; }
        if (e2<=dx){ err+=dx; y0+=sy; }
    }
}

void oled_circle(int cx,int cy,int r){
    int x=r,y=0,err=0;
    while (x>=y){
        oled_pixel(cx+x,cy+y);
        oled_pixel(cx+y,cy+x);
        oled_pixel(cx-y,cy+x);
        oled_pixel(cx-x,cy+y);
        oled_pixel(cx-x,cy-y);
        oled_pixel(cx-y,cy-x);
        oled_pixel(cx+y,cy-x);
        oled_pixel(cx+x,cy-y);
        y++;
        if (err<=0) err+=2*y+1;
        else { x--; err-=2*x+1; }
    }
}

// -------------------------------------------------------
// MPU6050
// -------------------------------------------------------
void mpu_init(){
    i2c_write_reg(MPU6050_ADDR, REG_PWR_MGMT_1, 0x00);
}

float mpu_gyro_z(){
    uint8_t b[2];
    i2c_read_reg(MPU6050_ADDR, REG_GYRO_ZOUT_H, b, 2);
    int16_t raw=(b[0]<<8)|b[1];
    return raw/131.0f;
}

// -------------------------------------------------------
// SPLASH
// -------------------------------------------------------
void splash(const char *s){
    oled_clear();
    oled_text(30,28,s);
    oled_update();
    vTaskDelay(pdMS_TO_TICKS(800));
}

// -------------------------------------------------------
// MAIN
// -------------------------------------------------------
void app_main(){

    // I2C Init
    i2c_config_t cfg = {
        .mode=I2C_MODE_MASTER,
        .sda_io_num=SDA_PIN,
        .sda_pullup_en=GPIO_PULLUP_ENABLE,
        .scl_io_num=SCL_PIN,
        .scl_pullup_en=GPIO_PULLUP_ENABLE,
        .master.clk_speed=400000
    };
    i2c_param_config(I2C_PORT,&cfg);
    i2c_driver_install(I2C_PORT,I2C_MODE_MASTER,0,0,0);

    // OLED Init
    oled_cmd(0xAE);
    oled_cmd(0x20); oled_cmd(0x00);
    oled_cmd(0xA6);
    oled_cmd(0xAF);

    // Splash sequence
    splash("Welcome");
    splash("Vacuum");
    splash("Robot");
    splash("Starting");
    splash("Ready!");

    // MPU init
    mpu_init();

    // Loop
    while (1) {
        oled_clear();
        float z = mpu_gyro_z();

        oled_text(0,0,"IMU Z:");
        char buf[32];
        snprintf(buf,sizeof(buf),"%.2f deg/s",z);
        oled_text(0,10,buf);

        oled_circle(64,32,25);
        float rad = z * 0.0174533f;
        int x = 64 + cosf(rad)*20;
        int y = 32 + sinf(rad)*20;
        oled_line(64,32,x,y);

        oled_update();
        vTaskDelay(pdMS_TO_TICKS(50));
    }
}

